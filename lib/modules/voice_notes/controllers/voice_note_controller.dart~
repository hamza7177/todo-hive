import 'dart:async';

import 'package:flutter_sound/flutter_sound.dart';
import 'package:get/get.dart';
import 'package:hive/hive.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';
import 'package:just_audio/just_audio.dart';
import 'package:permission_handler/permission_handler.dart';

import '../models/voice_note_model.dart';

class VoiceNoteController extends GetxController{
  var selectedFilter = "All".obs;



  late FlutterSoundRecorder _recorder;
  late AudioPlayer audioPlayer;
  RxBool isRecording = false.obs;
  RxBool isPlaying = false.obs;
  RxList<VoiceNote> voiceNotes = <VoiceNote>[].obs;
  late Box<VoiceNote> voiceBox;
  String? currentRecordingPath;
  RxDouble recordingProgress = 0.0.obs;

  StreamSubscription? _recordingProgressSubscription; // To manage the subscription

  @override
  void onInit() async {
    super.onInit();
    _recorder = FlutterSoundRecorder();
    audioPlayer = AudioPlayer();
    try {
      await _recorder.openRecorder();
      print('Recorder opened successfully');
    } catch (e) {
      print('Error opening recorder: $e');
      Get.snackbar('Error', 'Failed to initialize recorder: $e');
    }
    voiceBox = await Hive.openBox<VoiceNote>('voiceNotes');
    loadVoiceNotes();
  }

  void setFilter(String filter) {
    selectedFilter.value = filter;
    loadVoiceNotes(); // Reload notes based on filter
  }

  void loadVoiceNotes() {
    final allNotes = voiceBox.values.toList();
    if (selectedFilter.value == "Starred") {
      voiceNotes.value = allNotes.where((note) => note.isStarred).toList();
    } else {
      voiceNotes.value = allNotes; // "All" filter
    }
  }

  Future<bool> checkMicrophonePermission() async {
    var status = await Permission.microphone.status;
    if (status.isDenied || status.isPermanentlyDenied) {
      status = await Permission.microphone.request();
      if (status.isPermanentlyDenied) {
        Get.snackbar('Permission Required', 'Please enable microphone access in settings.');
        await openAppSettings();
        return false;
      }
    }
    return status.isGranted;
  }

  Future<void> startRecording() async {
    try {
      print('Attempting to start recording...');
      if (await checkMicrophonePermission()) {
        Get.snackbar('Permission Granted', 'Starting recording...');
        Directory tempDir = await getTemporaryDirectory();
        String path = '${tempDir.path}/${DateTime.now().millisecondsSinceEpoch}.aac';
        await _recorder.startRecorder(toFile: path);
        currentRecordingPath = path;
        isRecording.value = true;
        recordingProgress.value = 0.0;

        // Cancel any existing subscription to prevent duplicates
        await _recordingProgressSubscription?.cancel();

        // Listen to progress events
        _recordingProgressSubscription = _recorder.onProgress!.listen(
              (event) {
            recordingProgress.value = event.duration.inSeconds.toDouble();
            print('Recording progress: ${recordingProgress.value} seconds');
            if (recordingProgress.value >= 60) {
              stopRecording();
            }
          },
          onError: (error) {
            print('Error in recording progress: $error');
            Get.snackbar('Error', 'Failed to track recording progress: $error');
          },
        );

        // Fallback timer (optional) to ensure progress updates even if onProgress fails
        Future.delayed(const Duration(seconds: 1), () {
          _updateProgressPeriodically();
        });
      } else {
        Get.snackbar('Permission Denied', 'Microphone permission is required to record audio.');
      }
    } catch (e) {
      Get.snackbar('Error', 'Failed to start recording: $e');
      print('Error starting recording: $e');
    }
  }

  Future<void> pauseRecording() async {
    if (isRecording.value) {
      await _recorder.pauseRecorder();
      isRecording.value = false;
      _recordingProgressSubscription?.pause(); // Remove 'await' since pause() returns void
    }
  }

  Future<void> resumeRecording() async {
    if (!isRecording.value && currentRecordingPath != null) {
      await _recorder.resumeRecorder();
      isRecording.value = true;

      // Cancel any existing subscription to prevent duplicates
      await _recordingProgressSubscription?.cancel();

      // Resume listening to progress
      _recordingProgressSubscription = _recorder.onProgress!.listen(
            (event) {
          recordingProgress.value = event.duration.inSeconds.toDouble();
          print('Recording progress: ${recordingProgress.value} seconds');
          if (recordingProgress.value >= 60) {
            stopRecording();
          }
        },
        onError: (error) {
          print('Error in recording progress: $error');
          Get.snackbar('Error', 'Failed to track recording progress: $error');
        },
      );

      // Fallback timer
      Future.delayed(const Duration(seconds: 1), () {
        _updateProgressPeriodically();
      });
    }
  }

  Future<void> stopRecording([String? title]) async {
    try {
      await _recorder.stopRecorder();
      isRecording.value = false;
      recordingProgress.value = 0.0;

      // Cancel the progress subscription
      await _recordingProgressSubscription?.cancel();
      _recordingProgressSubscription = null;

      if (currentRecordingPath != null) {
        final voiceNote = VoiceNote(
          title: title ?? 'Untitled Note',
          audioPath: currentRecordingPath!,
          createdAt: DateTime.now(),
        );

        await voiceBox.add(voiceNote);
        voiceNotes.add(voiceNote);
        currentRecordingPath = null;
      }
    } catch (e) {
      Get.snackbar('Error', 'Failed to save recording: $e');
    }
  }

  // Fallback method to update progress periodically (1 second intervals)
  void _updateProgressPeriodically() {
    if (isRecording.value && recordingProgress.value < 60) {
      Future.delayed(const Duration(seconds: 1), () {
        recordingProgress.value += 1;
        _updateProgressPeriodically(); // Recursive call until recording stops
      });
    }
  }

  Future<void> playVoiceNote(String audioPath) async {
    try {
      await audioPlayer.setAudioSource(AudioSource.uri(Uri.parse(audioPath)));
      isPlaying.value = true;
      await audioPlayer.play();
      audioPlayer.playerStateStream.listen((state) {
        if (state.processingState == ProcessingState.completed) {
          isPlaying.value = false;
        }
      });
    } catch (e) {
      Get.snackbar('Error', 'Failed to play audio: $e');
    }
  }

  Future<void> pauseVoiceNote() async {
    await audioPlayer.pause();
    isPlaying.value = false;
  }

  void deleteVoiceNote(int index) {
    voiceBox.deleteAt(index);
    voiceNotes.removeAt(index);
  }

  Future<void> toggleStarred(int index) async {
    final note = voiceBox.getAt(index);
    if (note != null) {
      note.isStarred = !note.isStarred;
      await note.save(); // Save the updated note to Hive
      loadVoiceNotes(); // Refresh the list based on current filter
    }
  }
  @override
  void onClose() {
    _recorder.closeRecorder();
    audioPlayer.dispose();
    _recordingProgressSubscription?.cancel();
    super.onClose();
  }
}